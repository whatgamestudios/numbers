using UnityEngine;

using System;
using System.Security.Cryptography;


public class SeedGen{

    /**
     * Generate a seed value to generate values from, based on the number of days since 
     * the start of the game epoch, the game being played, and the iteration of the game. 
     *
     * @param game The game being played.
     * @param iteration The iteration of the game being played.
     * @returns A seed value to be presented to calls to GetNextValue.
     */
    public static byte[] GenerateSeed(uint game, uint iteration) {
        uint daysSinceStart = Timeline.DaysSinceEpochStart();
        byte[] d = BitConverter.GetBytes(daysSinceStart);
        byte[] g = BitConverter.GetBytes(game);
        byte[] i = BitConverter.GetBytes(iteration);

        byte[] derivationPath = new byte[d.Length + g.Length + i.Length];
        System.Buffer.BlockCopy(d, 0, derivationPath, 0, d.Length);
        System.Buffer.BlockCopy(g, 0, derivationPath, d.Length, g.Length);
        System.Buffer.BlockCopy(i, 0, derivationPath, d.Length + g.Length, i.Length);

//        HashAlgorithm sha = SHA3_256.Create();
        HashAlgorithm sha = SHA256.Create();
        return sha.ComputeHash(derivationPath);
    }


    /**
     * Calculate the next value in the sequence.
     *
     * @param seed Value generated by GenerateSeed
     * @param count The value from the sequence to return. This should increase from 0 as a game is played.
     * @param mod One more than the maximum value that should be returned.
     */
    public static uint GetNextValue(byte[] seed, uint count, uint mod) {
        byte[] c = BitConverter.GetBytes(count);

        byte[] combined = new byte[seed.Length + c.Length];
        System.Buffer.BlockCopy(seed, 0, combined, 0, seed.Length);
        System.Buffer.BlockCopy(c, 0, combined, seed.Length, c.Length);

//        HashAlgorithm sha = SHA3_256.Create();
        HashAlgorithm sha = SHA256.Create();
        byte[] raw = sha.ComputeHash(combined);
        uint raw1 = BitConverter.ToUInt32(raw, 0);
        return raw1 % mod;
    }

    
}
